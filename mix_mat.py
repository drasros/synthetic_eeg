import os
import time
import numpy as np
from scipy.special import lpmv


# TODO: numba, see of fast enough on cpu for online generation

# ---------------------------------------------------
# ACKNOWLEDGEMENTS
# ----
# initial code from Naess et al., 
# 'Four-sphere head model for EEG signals revisited'
# http://www.biorxiv.org/content/early/2017/04/06/124875
# https://github.com/Neuroinflab/fourspheremodel/blob/master/analytical_correct.py

# Modifications:
#    * code adapted for full waves generation with many sources (at any position,
#      , not only rz), and many reference electrode positions
#    * vectorized code for faster execution
#    * Sources are not specified in terms of (begin, end) of the dipole
#      vector anymore, but simply with (p, theta, phi) of the current dipole

# ---------------------------------------------------
# WHAT THIS PIECE OF CODE DOES
# 
# === Calculate 'transfer matrices' for all source->electrode pairs
#   (radial and tangential) ====
#
# NOTE: we are considering only electrodes on the surface of the brain
# (r_elec = r_scalp)
# 
# Then (in other file): choose activities for dipoles and generate samples


# ----------------------------------------------------
# NOTE ON ELECTROSTATIC POTENTIAL generated by current dipoles
# n_source dipoles
# n_elect electrodes
# n_coeff legendre polynomial coefficients
#
# The (simplified) form of the expression of the electrostatic potential
# on the surface, as described in paper, is: 
# (radial version, tan version similar)
# phi_potential = p * [1/ K * 
#       sum_{n_coeff}[A_n(source)] n P_n(cos theta(electrode|dipole))]
# 
# where: 
# p is the dipolar moment (radial part)
# K is a constant
# A_n depends on source position and n: size n_coeff*n_sources
# P_n (legendre polynomial) depends on n_coeff
# cos theta depends on source/elec pair: size n_sources*n_elec
#
# The part between brackets is the (in/out) term between p and potential
# The matrix of this bracket term for all source/elec combinations
# is the mixing matrix.
# 
# In the end we want to obtain 2 n_sources*n_elec matrices
# (one for radial, one for tangential)


########## GEOMETRIC AND PHYSICAL PARAMS #########
# All numbers in cm
r_geom = {
    'brain': 7.9,
    'csftop': 8.,
    'skull': 8.5,
    'scalp': 9., 
}

sigma_brain = 1. / 300.  # S / cm
sigma_scalp = sigma_brain
sigma_csf = 5 * sigma_brain
#sigma_skull20 = sigma_brain / 20.
sigma_skull = sigma_brain / 40.
#sigma_skull80 = sigma_brain / 80.
sigmas = {
    'brain': sigma_brain,
    'scalp': sigma_scalp,
    'csf': sigma_csf,
    'skull': sigma_skull,
}

# from gmsh sphere_4.geo
whitemattervol = 32
graymattervol = 64
csfvol = 96
skullvol = 128
scalpvol = 160

########## ELECTRODE POSITIONS ##################
# We will always use the same electrode positions
# so let's define them here. 
#'electrode': [theta, phi]
# taken from the easycap manual
elec_10_20_coords = {
    'Fp1': [-90, -72],
    'Fp2': [90, 72],
    'F3': [-60, -51],
    'F4': [60, 51],
    'C3': [-45, 0],
    'C4': [45, 0],
    'P3': [-60, 51],
    'P4': [60, -51],
    '01': [-90, 72],
    '02': [90, -72],
    'F7': [-90, -36],
    'F8': [90, 36],
    'T7': [-90, 0],
    'T8': [90, 0],
    'P7': [-90, 36],
    'P8': [90, -36],
    'Fz': [45, 90],
    'Cz': [0, 0],
    'Pz': [45, -90],
    }

########## COORDINATE SYSTEM ##################
# In the following, spherical input coordinates for sources and
# electrodes will be used. (optional cartesian coords for
# sources). Shape of coords_elec: (n_elec, 3) 


##### Static functions ##########################
# Unfortunately, the V, Y, Z, A and B depend on dipole position

def get_r_ij(r_sources, r_geom): # make it depend on rads!
    rz = r_sources
    rz1 = rz / r_geom['brain']
    r12 = r_geom['brain'] / r_geom['csftop']
    r23 = r_geom['csftop'] / r_geom['skull']
    r34 = r_geom['skull'] / r_geom['scalp']

    r1z = 1. / rz1
    r21 = 1. / r12
    r32 = 1. / r23
    r43 = 1. / r34

    r_list = [rz, rz1, r12, r23, r34, r1z, r21, r32, r43]
    # each element in r_list has length n_sources
    return r_list

def get_sigmas_ij(sigmas):
    s12 = sigmas['brain'] / sigmas['csf']
    s23 = sigmas['csf'] / sigmas['skull']
    s34 = sigmas['skull'] / sigmas['scalp']
    return s12, s23, s34

def get_V_Y_Z(n, r_list, sigmas):
    # get coefficient A, B in expression of electric potential
    # these result from resolution of the Poisson equation in successive spheres

    # for possible use with n=np.arange(100) for example
    # and r_list containing elements of length n_sources

    # make n have dim [len(n), 1]
    # make r_list have dim [1, n_sources]
    n = np.expand_dims(n, axis=1)
    r_list = [np.expand_dims(elmt, axis=0) for elmt in r_list]

    s12, s23, s34 = get_sigmas_ij(sigmas)

    # with broadcasting, a multiplication n*r_elmt has shape 
    # [len(n), n_sources]
    [rz, rz1, r12, r23, r34, r1z, r21, r32, r43] = r_list
    # V ------------------------
    k = (n+1.) / n
    Factor = ( ( r34**n - (r43**(n+1)) ) / ( (k*(r34**n)) + (r43**(n+1)) ) )
    num = (s34/k) - Factor
    den = s34 + Factor
    V = num / den
    # Y ------------------------
    k = n / (n+1.)
    Factor = ( ( (r23**n) * k) - V*(r32**(n+1))) / (r23**n + V*(r32**(n+1)))
    num = (s23*k) - Factor
    den = s23 + Factor
    Y = num / den
    # Z ------------------------
    k = (n+1.) / n
    num = (r12**n - k*Y*(r21**(n+1)) ) / (r12**n + Y*(r21**(n+1)))
    Z = num
    return V, Y, Z # shapes [len(n), n_sources]

def get_A4_B4(n, r_list, sigmas, V, Y, Z):
    # get coefficient A, B in expression of electric potential
    # these result from resolution of the Poisson equation in successive spheres
    # n can be a list for example np.arange(100)
    # r_list can be a list of elemts of length n_sources each

    # REM: we need A4, B4 not the others, because electrodes on the surface of the scalp

    s12, s23, s34 = get_sigmas_ij(sigmas)
    
    V, Y, Z = get_V_Y_Z(n, r_list, sigmas)
    # same remark for broadcasting
    n = np.expand_dims(n, axis=1)
    r_list = [np.expand_dims(elmt, axis=0) for elmt in r_list]
    
    [rz, rz1, r12, r23, r34, r1z, r21, r32, r43] = r_list
    # A1 ------------------------
    num = (rz1**(n+1))* (Z + s12*((n+1.)/n))
    den = s12 - Z
    A1 = num / den
    # A2 ------------------------
    num = A1 + (rz1**(n+1))
    den = (Y*(r21**(n+1))) + r12**n
    A2 = num / den
    # B2 ------------------------
    B2 = A2*Y
    # A3 ------------------------
    num = A2 + B2
    den = r23**n + (V*(r32**(n+1)))
    A3 = num / den
    # B3 ------------------------
    B3 = A3*V
    # A4 ------------------------
    num = A3 + B3
    k = (n+1.) / n
    den = (k*(r34**n)) + (r43**(n+1))
    A4 = k*(num / den)
    # B4 ------------------------
    B4 = A4* (n / (n+1.))
    return A4, B4 # shapes [len(n), n_sources]

# here we consider only electrodes on the surface of the scalp
# so we don't need H from the original code

# Because get_rotation_matrix uses cartesian coordinates, 
# let's define the coordinate change functions that we need:
def spherical_to_cart(coords_spherical):
    r = coords_spherical[..., 0]
    theta = coords_spherical[..., 1]
    phi = coords_spherical[..., 2]
    # r, theta, phi have shapes (n_elements,)
    x = r * np.sin(theta) * np.cos(phi)
    y = r * np.sin(theta) * np.sin(phi)
    z = r * np.cos(theta)
    coords_cart = np.stack([x, y, z], axis=-1)
    return coords_cart

def cart_to_spherical(coords_cart):
    x = coords_cart[..., 0]
    y = coords_cart[..., 1]
    z = coords_cart[..., 2]
    # x, y, z have shapes (n_elements,)
    r = np.sqrt(np.square(x) + np.square(y) + np.square(z))
    theta = np.arccos(z / r)
    phi = np.arctan2(y, x) # arctan2 for choosing the right quadrant
    coords_spherical = np.stack([r, theta, phi], axis=-1)
    return coords_spherical

def check_scalar_products(origin_vector, target_vectors):
    #check no pair of origin_v, target_v point in exactly opposite directions

    # REM: use this function after sources positioning to reallocate source
    # in the (unlikely) event that it is exactly opposite one electrode
    origin_vectors = np.expand_dims(origin_vectors, axis=1) #(n_origin_elmts, 1, 3)
    target_vectors = np.expand_dims(target_vectors, axis=0) #(1, n_target_elmts, 3)
    c = np.sum(np.multiply(origin_vectors, target_vectors), axis=-1)
    loc = np.where(c==-1.)
    everything_ok = np.size(loc)==0
    if everything_ok:
        return None
    else:
        return loc

def get_rotation_matrix(origin_vectors, target_vectors):

    # get rotation matrices that transform origin_vectors into target_vectors
    # origin_vectors: shape (n_origin_elements, 3), cartesian coords
    # target_vectors: shape (n_target_elements, 3), cartesian coords

    # uses broadcasting (now supported in np.cross)

    # In our case, we will use ONE target vector, i.e. the z axis
    # (because in expression of potential, dipole is on z)

    # linalg for obtaining rotation matrix:
    #https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d
    
    # vectors must be unit vectors
    origin_norms = np.expand_dims(
        np.linalg.norm(origin_vectors, axis=1), axis=1)
    origin_vectors = origin_vectors / origin_norms
    target_norms = np.expand_dims(
        np.linalg.norm(target_vectors, axis=1), axis=1)
    target_vectors = target_vectors / target_norms

    l_origin = origin_vectors.shape[0]
    l_target = target_vectors.shape[0]

    origin_vectors = np.expand_dims(origin_vectors, axis=1) #(n_origin_elmts, 1, 3)
    target_vectors = np.expand_dims(target_vectors, axis=0) #(1, n_target_elmts, 3)

    v = np.cross(origin_vectors, target_vectors)
    s = np.linalg.norm(v, axis=-1)
    c = np.sum(np.multiply(origin_vectors, target_vectors), axis=-1)

    z = np.zeros((l_origin, l_target))
    vx = [[z, -v[:, :, 2], v[:, :, 1]],
          [v[:, :, 2], z, -v[:, :, 0]],
          [-v[:, :, 1], v[:, :, 0], z]] # shape (3, 3, l_origin, l_target)
    # , can we find something more efficient ?
    vx = np.transpose(vx, (2, 3, 0, 1)) # now shape (l_origin, l_target, 3, 3)

    # expand dims twice for c to bring allow division
    c = np.expand_dims(c, axis=-1)
    c = np.expand_dims(c, axis=-1)
    R = np.tile(
        np.eye(3), 
        (l_origin, l_target, 1, 1)) + vx + np.matmul(vx, vx) / (1. + c)
    # (not applicable if c = -1., i.e. origin and target point
    # in exactly opposite directions)
    return R # has shape (l_origin, l_target, 3, 3)

def get_elec_coords_in_sources_ref(coords_elec, coords_sources, 
                                   sources_ref='sph'):
    # coords_elec in spherical coordinates,
    # coords_sources in spherical coordinates or cart, 
    # shapes (n_elemts, 3)
    # get (spherical) coords of all electrodes
    # in the referential of all sources

    if not (sources_ref=='sph' or sources_ref=='cart'):
        raise ValueError('elect_ref must be \'sph\' or \'cart\'')

    n_elec = coords_elec.shape[0]
    coords_elec = spherical_to_cart(coords_elec) #shape (n_elec, 3)
    if sources_ref == 'sph':
        coords_sources = spherical_to_cart(coords_sources)

    # rotations to transform sources to z axis
    z = np.expand_dims(np.array([0, 0, 1]), axis=0)
    R = get_rotation_matrix(coords_sources, z)
    # shape (n_sources, 1, 3, 3)

    # Now apply to electrodes the rotations to get their coordinates
    # in sources referential
    # coord_elec_transformed = matmul(R_s, coord_elec)
    coords_elec = np.expand_dims(coords_elec, axis=0) #shape (1, n_elec, 3)
    coords_elec = np.expand_dims(coords_elec, axis=-1) #shape (1, n_elec, 3, 1)
    coords_elec_ref_sources = np.matmul(R, coords_elec)
    coords_elec_ref_sources = np.reshape(
        coords_elec_ref_sources, (-1, n_elec, 3))
    # shape (n_sources, n_elec, 3)

    # back to spherical
    coords_elec_ref_sources = cart_to_spherical(
        coords_elec_ref_sources)
    return coords_elec_ref_sources


def get_mixmats(coords_elec, coords_sources, 
                r_geom, sigmas, n_legendre=100):
    # return 'mixing matrices' from dipole caracs to potentials at electrodes

    # also has some profiling to see whether there are some bottlenecks

    t_prepare = time.time()
    n = np.arange(1, n_legendre)
    n_sources = coords_sources.shape[0]

    mul_fac = 1. / (4*np.pi*sigmas['brain'])

    r_sources = coords_sources[:, 0]
    r_list = get_r_ij(r_sources, r_geom)
    rz = r_list[0] # (n_sources,)
    rz2 = np.square(rz.reshape(-1, 1)) # (n_sources, 1)

    V, Y, Z = get_V_Y_Z(n, r_list, sigmas) #shapes (n_legendre, n_sources)
    A4, B4 = get_A4_B4(n, r_list, sigmas, V, Y, Z) # shapes (n_legendre, n_sources)

    coords_elec_ref_sources = get_elec_coords_in_sources_ref(
        coords_elec, coords_sources)
    thetas = coords_elec_ref_sources[:, :, 1]
    cos_thetas = np.cos(thetas)
    phis = coords_elec_ref_sources[:, :, 2]
    sin_phis = np.sin(phis)
    cos_phis = np.cos(phis)
    # shapes (n_sources, n_elec)
    t_prepare = time.time() - t_prepare
    print('Preparation of mixing matrices calculation done in %s seconds.' % str(t_prepare))

    # ----------------
    # radial part: this uses LEGENDRE POLYNOMIALS
    # REM: *np.polynomial.legendre.Legendre is NOT broadcastable
    #      *np.polynomial.legendre.legval NEITHER. (it just calculates all combinations)
    # So we have to loop on sources... 
    t_radial = time.time()
    # coeff in front of legendre polynomials:
    H = (A4 + B4) * n.reshape(n_legendre-1, 1) # shape (n_legendre, n_sources)
    # add element for n=0 (np.polynomial.legendre starts at 0, our formula at 1)
    H = np.insert(H, 0, np.zeros(n_sources)).reshape((-1, n_sources))
    # (actually, insert probably changes nothing..)
    legendre_sources = [
        np.polynomial.legendre.legval(
            x=cos_thetas[idx, :], c=H[:, idx]) for idx in range(n_sources)]
    # list with n_sources elements each of size (n_elec,)
    m_radial = np.stack(legendre_sources, axis=0) # shape (n_sources, n_elec)
    m_radial = (mul_fac / rz2) * m_radial
    t_radial = time.time() - t_radial
    print(('Radial part of mixing matrix calculated' 
           'in %s seconds.' % str(t_radial)))
    
    # TANGENTIAL PARTS: The original article is condidering a tangential
    # part of the current dipole where the dipole is in the direction
    # of AXIS Y. In real life in 3d, a dipole has three orientations
    # so we also need the tangential part for a dipole in the direction
    # of AXIS X. Of course this is the same formula except that 
    # this time the angle is (phi + pi / 2)
    # ----------------
    # tangential part: this uses LEGENDRE ASSOCIATED POLYNOMIALS,
    # (different from legendre polynomials!!)
    # this time we have to loop on coeffs (range(n_legendre))

    # TANGENTIAL PART Y
    t_tangential = time.time()
    # coeffs in front of polynomials
    H = np.expand_dims((A4 + B4), axis=-1) # now (n_legendre, n_sources, 1)

    legendre_assoc_nlist = [lpmv(
        1, deg, cos_thetas) for deg in n]
    # list of n_legendre elements of shape [n_sources, n_elec]
    legendre_assoc = np.stack(legendre_assoc_nlist, axis=0)
    # (n_legendre, n_sources, n_elec)
    s = np.sum(H * legendre_assoc, axis=0)
    m_tangential_y = sin_phis * s # (n_sources, n_elec)
    m_tangential_y = - (mul_fac / rz2) * m_tangential_y
    m_tangential_x = cos_phis * s
    m_tangential_x = - (mul_fac / rz2) * m_tangential_x

    t_tangential = time.time() - t_tangential
    print(('Tangential parts of mixing matrix calculated' 
           'in %s seconds.' % str(t_tangential)))

    times = (t_prepare, t_radial, t_tangential) # for profiling

    return m_radial, m_tangential_x, m_tangential_y 
    # shapes of the m: (n_sources, n_elec)


def get_spread_points_on_sphere(n=256, r=1., cortex_only=True,
                                return_cartesian=False):  
    # no points are sampled on a sphere uniformly:
    # see http://blog.marmakoide.org/?p=1 (spreading points on a sphere)
    #
    # if cortex_only is true, among the n points only the ones 
    # corresponding to where the cortex would be are kept.
    # In the 10-20 representation the cortex goes pi/8 further
    # than the lowermost electrode.  

    golden_angle = np.pi * (3 - np.sqrt(5))
    theta = golden_angle * np.arange(n)
    z = np.linspace(1 - 1.0 / n, 1.0 / n - 1, n)
    radius = np.sqrt(1 - z * z)
     
    points = np.zeros((n, 3))
    points[:,0] = radius * np.cos(theta)
    points[:,1] = radius * np.sin(theta)
    points[:,2] = z
    points = r * points

    if cortex_only:
        idx_in_cortex = np.where(
            points[:, 2] >= - r * np.sin(np.pi/8.))[0]
        points = points [idx_in_cortex]
        print('Remaining dipoles: ', len(points))

    if not return_cartesian:
        points = cart_to_spherical(points)

    return points




    




